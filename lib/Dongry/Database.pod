=head1 NAME

Dongry::Database - Dongry database object

=head1 SYNOPSIS

  use Dongry::Database;
  my $db = Dongry::Database->new
      (sources => {default => {dsn => $dsn},
                   master => {dsn => $dsn, writable => 1}});
  
  $db->execute ('CREATE TABLE table1 (col1 INT, date DATE)
                 ENGINE=InnoDB');
  $db->execute ('INSERT INTO table1 (col1) VALUES (?), (?)', [10, 2]);
  
  my $transaction = $db->transaction;
  $db->insert ('table1', [{col1 => 12, date => '2012-01-02'}]);
  $db->update ('table1', {date => '2001-10-02'},
               where => {col1 => {'<', 5}});
  $transaction->commit;
  
  $db->select ('table1', {col1 => $value})->each_as_row (sub {
    warn $_->get ('date')->ymd ('/'), "\n";
  });
  
  my $table = $db->table ('table1'); # Dongry::Table
  my $query = $db->query (...);      # Dongry::Query

=head1 DESCRIPTION

B<Dongry> is a lightweight Perl interface to MySQL databases.  It
provides different levels of abstractions for applications to handle
database operations in easy, memorable, and safe ways without losing
full control of how and when SQL queries are executed.

=head1 METHODS OF DATABASE OBJECT

The most important object in Dongry is the database object.  The
database object is an instance of the C<Dongry::Database> class and
provides several levels of APIs for accessing a specific database.  It
has following methods:

=head2 Instantiation

There are two ways to instantiate database objects.  One is the C<new>
constructor method, by which you can always obtain a new instance of
the database object.  The other is the C<load> method to lookup the
database object from the registry by the short name for the object.

=over 4

=item $db = Dongry::Database->new (%opts)

Create and return a new instance of the L<Dongry::Database> database
object.

Options C<sources>, C<onconnect>, C<onerror>, and C<schema> can be
specified as key-value pairs.  See following subsections for their
semantics and acceptable values.

Example:

  my $db = Dongry::Database->new (sources => {
    default => {dsn => ..., username => ..., password => ...},
    master => {dsn => ..., username => ..., password => ...},
  }, onconnect => sub {
    my ($self, %args) = @_;
    warn $args{source_name}, ": Connected";
  });

=item $Dongry::Database::Registry->{$db_name} = {...}

=item $db = Dongry::Database->load ($db_name)

Instead of creating a new instance each time, a named database object
instance can be retrieved by this method.

Before the first invocation with the name the application has to
register a short name for the database object instance with its
initializing options as a key-value pair of
C<%$Dongry::Database::Registry> hash.

The hash key is the short database name and the hash value is the hash
reference containing options used to instantiate the database object.
Following options allowed for the C<new> method is also applicable
here: C<sources>, C<onconnect>, C<onerror>, and C<schema>.

Alteranatively, these values can be specified as code reference which
is invoked to get the actual value when an object is initialized, by
prefixing C<get_> to the hash key (i.e. C<get_schema> for C<schema>).
The code reference will be invoked without any argument.  The code
reference must return a value that is allowed for the option
(e.g. C<get_onconnect> code reference must return an C<onconnect>
handler code reference).

Then, you can use the short database name to get the instance
initialized with the specified options.  The instantiation happens
only once.  Invocations of the method with the same database name
always return the same database object instance.  You can control the
lifetime of the instances by accessing (e.g. clearing or
C<local>izing) the C<$Dongry::Database::Instances> hash reference.

Example:

  $Dongry::Database::Registry->{user} = {
    sources => {
      master => ...,
      default => ...,
    },
    onconnect => sub {
      warn "User connected";
    },
    get_schema => sub { return My::DatabaseInfo->schema },
  };
  $db = Dongry::Database->load ('user');
  $db2 = Dongry::Database->load ('user'); # same as $db

=back

=head2 Connections

A database object can have multiple (physically different) connections
to a (logically same) database.  Such a connection is identified by
short identifier known as I<data source name>, such as C<default> and
C<master>.  You can any non-false string as a data source name.
However, names C<default> and C<master> are sometimes handled in a
special way, as described in this and following subsections.

The C<default> data source is selected for read-only operations by
default.  The C<master> data source is selected for other operations
by default.  Operations in a transaction are always executed with the
C<master> data source.  These two data sources would be useful for
accessing databases operated in popular master-slave configuration.
In addition, you can define your custom data sources such as C<heavy>
or C<batch> to send some of queries to alternative slaves.

=over 4

=item $db->source ($source_name => $source_info)

=item $source_info = $db->source ($source_name)

=item $db = Dongry::Database->new (sources => {$source_name => $source_info, ...})

Get or set data source information for the specified data source name.
It is a hash reference containg following key-value pairs:

=over 4

=item dsn => string (REQUIRED)

The "dsn" string used to connect the database.  See L<DBI> for more
information.

=item username => string

The user name used to connect the database.  This is optional if the
database or the database driver module does not require user name.

=item password => string

The password used to connect the database.  This is optional if the
database or the database driver module does not require password.

=item writable => boolean

Whether the database is writable or not.  If not writable, the
database module refuse to issue write operations as far as possible.
Default is false (i.e. not writable).

=item label => string

Informative name of the data source.  It is not used to connect to the
data source.  This value might or might not be useful for debugging.
Default is same as C<dsn>.

=back

=item $db->onconnect ($code)

=item $code = $db->onconnect

=item $db = Dongry::Database->new (onconnect => $code)

Get or set the code reference which is invoked when a new connection
is established.  The code reference, when invoked, receives the "self"
argument followed by zero or more key-value pairs.  The "self"
argument is the database object.  The key-value pairs would contain:

=over 4

=item source_name => string (ALWAYS)

The name of the data source used to establish the connection.

=back

The default C<onconnect> handler does nothing.

Please be aware the C<onconnect> handler is not safe place to execute
SQL statements in general because it could result in establishing
another connection within the C<onconnect> handler.  It is, however,
safe to execute an SQL statement using the same data source name as
given by the C<source_name> option.  It might be an interesting use
case of this handler to execute some configuration statements
(e.g. C<SET time_zone> statement) for the connection in the handler.

Example:

  $Dongry::Database::Registry->{hoge} = {
    ...
    onconnect => sub {
      my ($self, %args) = @_;
      $self->execute ('set time_zone = "+00:00"', [],
                      even_if_read_only => 1,
                      ## This is important!
                      source_name => $args{source_name});
    },
  }:

=item $db->onerror ($code)

=item $code = $db->onerror

=item $db = Dongry::Database->new (onerror => $code)

Get or set the code reference which is invoked when an error is
detected during various operations, such as connection to databases or
execution of queries.  The code reference, when invoked, receives the
"self" argument followed by zero or more key-value pairs.  The "self"
argument is the database object.  The key-value pairs would contain:

=over 4

=item source_name => string (ALWAYS)

The name of the data source for the relevant database connection.

=item text => string

A short string describing the situation, if available.  This is
typically an error message from the underlying L<DBI> or database
driver modules.

=item sql => string

The SQL statement being executed, if any.

=back

The default C<onerror> handler prints the error message to the
standard error output.

Please don't do anything much more complex than just reporting the
error to someone else.  In particular, don't try to execute another
SQL statement in the error handler, as it would likely result in
another SQL execution error, which would recursively invoke the same
error handler.

You can throw an exception (or simply C<die>) in the error handler.
In anyway, an exception is thrown just after the error handler
returns.

=item $db->connect ($source_name)

Connect to the data source whose name is specified by the argument, if
any, or the C<default> data source, otherwise.  If there is already a
connection established for the specified data source, the method does
nothing.  After a connection has been established, the C<onconnect>
handler is invoked.

You don't have to invoke this method explicitly in general.  This
method is automatically invoked at the first time an operation that
requires the connection is enforced.

=item $db->disconnect ($source_name)

If a data source name is specified, disconnect the connection for the
data source.  Otherwise, disconnect all the connections hold by the
database object.  If there is no connection for the data source, the
method does nothing.

Please notice that if there is an uncommitted transaction session, it
will be rollbacked by the invocation of this method.

You don't have to invoke this method explicitly in general, as the
C<DESTROY> method for the database object will invoke this method
automatically.

=back

By default SQL executions are automatically committed
(i.e. C<AutoCommit> option of the L<DBI> object is set to true).  Use
of transaction object can override this behavior:

=over 4

=item $transaction = $db->transaction

Start a transaction and return the transaction object.  The
transaction object is a "guard" object; The transaction is effective
as long as the object is live.

=back

Once you get a transaction object, you can invoke SQL operations as
usualm through various methods of Dongry.  In addition, the C<lock>
option for C<select> and other retrieval methods will take effect in
transaction.  After execution of zero or more SQL statements, you have
to commit or rollback the transaction to save or discard the
modifications, using a method of the transaction object:

=over 4

=item $transaction->commit

Commit the transaction.  Changes will be persisted by the database.

=item $transaction->rollback

Rollback the transaction.  Changes will be discarded by the database.

=item $string = $transaction->debug_info

Return a string that shortly describes the object.  It might or might
not be useful for debugging.

=back

Exactly one of C<commit> and C<rollback> methods must be invoked to
terminate the transaction.  Once one of them are invoked, the
transaction object lost its effect, even if it has not been destroyed
by Perl.  This is different from usual "guard" objects, including the
"force source" object described below.  After this time you can start
another transaction session by calling the C<< $db->transaction >>
method again.  A new transaction cannot be initiated while there is
another transaction.

If you forgot to commit or rollback the changes, they will be
discarded when the transaction object is destroyed by Perl.  Don't
rely on this behavior since it is not guaranteed by Perl exactly when
an object is destroyed.  It means that exactly when the transaction
terminates is unclear unless you explicitly call the C<rollback>
method.

Within a transaction you can only use the C<master> data source.  The
default data source is C<master>, not C<default>, within a
transaction.

When you just want to use a particular data source for some
operations, you can use the "force source" feature:

=over 4

=item $force = $db->force_source_name ($source_name)

Return a "guard" object that forces the use of a data source specified
as the argument.

While the I<$force> object is in scope (or before the C<end> method of
the object is invoked), the C<execute> method and the other methods to
execute SQL statements act as if the C<source_name> option with the
given source name is specified, except that if the C<source_name> is
explicitly specified to use another data source for the method, the
method would report an error instead.

It is an error to call this method while there is an active I<$force>
object.  In other word, you cannot force a data source while another
data source is forced.  Likewise, you cannot start a transaction when
a data source is forced; and you cannot force a data source within a
transaction.  The transaction automatically forces the C<master> data
source.

=back

The "force" object has following methods:

=over 4

=item $force->end

End to force the data source.  Although this method is automatically
called when the I<$force> object is destroyed by Perl, it is
encouraged to call this method explicitly as Perl does not guarantee
the exact timing for the destruction of an object.

=item $string = $force->debug_info

Return a short string that might or might not be useful for debugging.

=back

=head2 Bare SQL operations

The bare SQL execution API of Dongry, i.e. the C<execute> method,
executes SQL statements provided by the application as is, with few
modifications.  It would be useful if you'd like to issue a complex or
rarely-used kind of SQL statement and if you really and completely
understand what you are doing.  For common operations such as
insertion and selection, please consider using more abstract APIs
described in following sections.

=over 4

=item $result = $db->execute ($sql, [$value1, $value2, ...], %opts)

=item $result = $db->execute ($sql, {param1 => $value1, ...}, %opts)

Execute an SQL statement.

B<SQL with anonymous placeholders>: The first argument is the SQL
statement to execute, which possibly contains placeholders (C<?>).
The second argument is an array reference, which contains values bound
to the placeholders.  The second argument can be omitted (i.e. can be
C<undef>) if there are no placeholders.

B<SQL with named placeholders>: The first argument is the SQL
statement to execute, which possibly contains named placeholders such
as C<:params>.  The second argument is a hash reference, which
contains name-value pairs bound to the placeholders.  For more
information on the I<named placeholders>, see L<Dongry::SQL>.

In addition, following key-value pairs can be specified as options:

=over 4

=item source_name => string

The name of the data source used to select the database connection.
If there is no connection established for the data source, the
C<connect> method with the source name is automatically invoked and
then the SQL statement is executed over that connection.

If this option is not specified, an appropriate data source is
determined.  In general the C<master> data source is chosen.  However,
if the SQL is known to read-only, i.e. it begins by C<SELECT>,
C<DESC>, or C<SHOW>, the C<default> data source is chosen.  Note that
transactions and "force source" objects would modify this default.

=item must_be_writable => boolean

If this option is set to true, the method would raise an error without
executing the SQL statement when the selected data source is I<not>
marked as I<writable>.

If this option is set to true and the C<source_name> option is I<not>
specified, the data source is set to C<master> even if the SQL
statement is considered as read-only.

=item even_if_read_only => boolean

If this option is set to true, the method would not raise an error
even when the SQL statement is not considered as read-only but the
selected data source is I<not> marked as I<writable>.

This option would be useful to issue an C<SET> statement to set
configuration options for the connection, as the method does not
consider the C<SET> statements as read-only but it should be applied
even to a read-only data source.

You should not specify both C<must_be_writable> and
C<even_if_read_only> options at the same time.

=back

The method would return a result object which is I<not> bound to any
table.  The number of affected rows (or the rows to be fetched) can be
retrieved from the C<row_count> method of the result object.  If the
SQL statement returns rows (e.g. C<SELECT> or C<SHOW>), they are
accessible from various methods of the result object.

=back

=head2 Structured SQL operations

Methods in this section provides abstraction for common patterns of
SQL executions, such as C<SELECT> and C<INSERT> statements with plain
arguments.  These methods construct SQL statements in favor of the
application from the given arguments, with appropriate quotations and
placeholders.

=over 4

=item $result = $db->insert ($table_name, [$values1, $values2, ...], %opts)

Inserts one or more rows.  The first argument must be the table name
into which the rows are inserted.  The second argument must be an
array reference which contains one or more hash references, each of
them is a row to be inserted (represented as column name/value pairs).
Unspecified columns are set to their default values.

In addition, following options can be specified as name-value pairs:

=over 4

=item source_name => string

The name of the data source used to select the database connection.
For more information on how data source is selected, see the
C<execute> method.

=item duplicate => "ignore" / "replace" / hashref

Specifies how "duplicate entry" error is handled by the database.

If C<ignore> is specified, an C<INSERT IGNORE> statement is issued
such that any duplicate insertion is ignored without errors.  Please
note that this statement might ignore other errors as well.

If C<replace> is specified, an C<REPLACE> statement is issued such
that any existing duplicate row is discarded before the insertion.

If a hash reference is specified, the C<ON DUPLICATE KEY UPDATE>
clause is appended to the C<INSERT> statement with the values
specified in the hash.  The format of the hash reference is same as
the second argument of the C<insert> method.

If this option is not specified, then a normal C<INSERT> statement is
issued such that any duplication would be reported as an SQL execution
error.

=back

This method returns a result object bound to the table specified as
the first argument.  The number of affected rows can be retrieved from
the C<row_count> method of the result object.  Althugh inserted rows
can be accessible from various methods of the result object, please be
careful that the object only holds the data as received as the
argument to the C<insert> method.  It might not reflect SQL-level
default values, auto-increment column values, server-side value
normalization, handling of C<duplicate> options, use of bare SQL
fragments, and so on.  If you really like to know what is inserted (or
not inserted) to the database, you have to select the inserted row(s)
by yourself.  In the case you explicitly specified the primary key
values in the values argument, the C<reload> method of the table row
object accessible from the result object could be useful for this
purpose.

Example:

  $db->insert ('mytable', [
    {id => 12, name => 'Foo', date => 0},
    {id => 13, name => 'Bar'},
    {id => 14, name => undef, date => '2012-03-01'},
  ]);
  # INSERT INTO `mytable` (`id`, `name`, `date`) VALUES
  #   ('12', 'Foo', '0'),
  #   ('13', 'Bar', DEFAULT),
  #   ('14', NULL, '2012-03-01')

=item $id = $db->last_insert_id

Returns the "last insert ID" as returned by the database.  It is
usually the auto-increment primary key value of the last inserted row.

=item $result = $db->select ($table_name, $where, %opts)

Selects rows from a table in the database.  Conditions to select rows,
i.e. the C<WHERE> clause of the SQL statement, must be specified as
the second argument, in L<SQL::Abstract> or L<SQL::NamedPlaceholder>
format.  Conditions in the L<SQL::Abstract> format must be specified
as a hash reference for the C<WHERE> clause.  Conditions in the
L<SQL::NamedPlaceholder> format must be specified as an array
reference containing the SQL statement template followed by zero or
more name-value pairs.

In addition, following options can be specified as name-value pairs:

=over 4

=item source_name => string

The name of the data source used to select the database connection.
For more information on how data source is selected, see the
C<execute> method.

=item must_be_writable => boolean

If this option is set to true, the method would raise an error without
executing the SQL statement if the selected data source is marked as
I<writable>.  For more information on how this option applies, see the
C<execute> method.

=item distinct => boolean

If this options is set to true, the C<DISTINCT> keyword is put in the
statement such that only a row is returned for a duplicate set of
rows.

=item fields => ...

The columns to retrieve, to be specified just after the C<SELECT>
keyword of the issued SQL statement.

If nothing is specified, or an C<undef> value is specified, all
columns, i.e. C<*>, are selected.

If a string is specified, that is considered as a column name.

If a bare SQL fragment object (returned by the C<bare_sql_fragment>
method) is specified, the specified string is used as is.

Hash references with name-value pairs are converted to function calls
whose function name is specified by the key and the argument is
specified by the value.  Following function names are available:
C<-count> (in SQL, C<COUNT()>), C<-min> (in SQL, C<MIN()>), C<-max>
(in SQL, C<MAX()>), and C<-sum> (in SQL, C<SUM()>).  In addition,
following name-value pairs can be specified in the hash reference: C<<
as => name >> names an alias for the function value (in SQL,
C<function() AS name>), and C<< distinct => boolean >> adds the
C<DISTINCT> keyword (in SQL, C<function(DISTINCT args)>).

These values can be combined as an array reference, for retrieving one
or more of those values.

Examples:

  [undef, 'c1']                   # *, `c1`
  [{-count => undef}, 'c1', 'c2'] # COUNT(*), `c1`, `c2`
  [{-count => 'c1',
    as => 'c',
    distinct => 1}]               # COUNT(DISTINCT `c1`) AS `c`

=item group => [column1, column2, ...]

The columns to use grouping, i.e. column names for the C<GROUP BY>
clause in the SQL statement.  Column names must be specified as an
array reference of strings.

=item order => [column1 => direction, column2 => direction, ...]

The columns and their orders for the sorting, i.e. values for the
C<ORDER BY> clause in the SQL statement.  They must be specified as
B<array> reference of name-value pairs, where names represent column
names and values represent their sort order.  The values must be
either C<ASC>, C<asc>, or C<1> (ascending order) or C<DESC>, C<desc>,
or C<-1> (descending order).

=item offset => number, limit => number

The offset and the number of rows to retrieve, i.e. values for the
C<LIMIT> clause in the SQL statement.  They must be specified as
non-negative integers.  If C<offset> is specified but C<limit> is not
specified, C<limit> is defaulted to C<1>.  Otherwise, the default for
C<offset> is zero and the default for C<limit> is inifinity.

=item lock => update/share

The lock mode for the C<SELECT> operation.  If the value is C<update>,
C<FOR UPDATE> option is included in the C<SELECT> statement.  If the
value is C<share>, C<LOCK IN SHARE MODE> option is included in the
C<SELECT> statement.

=back

This method returns a result object bound to the table specified as
the first argument.  The number of available rows can be retrieved
from the C<row_count> method of the result object.  The selected rows
can be accessible from one of C<all>, C<each>, and C<first> methods,
or their C<_as_row(s)> variants C<all_as_rows>, C<each_as_row>, and
C<first_as_row>.

Examples:

  my $result = $db->select
      ('table1',
       {col1 => 'hoge', col2 => 123, date => {'<=', '2001-02-02'}},
       order => [date => -1, col1 => 1, col2 => -1]);
  # SELECT * FROM `table1`
  #    WHERE `col1` = 'hoge' AND `col2` = '123' AND
  #          `date` <= '2001-02-02'
  #    ORDER BY `date` DESC, `col1` ASC, `col2` DESC;
  $result->each (sub {
    my $values = shift;
    warn $values->{date}, "\t", $values->{col1}, "\n";
  });

  my $result = $db->select
      ('table1',
       {col1 => 'hoge'},
       fields => [{-count => undef, distinct => 1, as => 'count'},
                  'col1', 'col2'],
       group => ['col2']);
  # SELECT COUNT(DISTINCT *) AS `count` FROM `table1`
  #     WHERE `col1` = 'hoge' GROUP BY `col2`
  $result->all_as_rows->each (sub {
    my $row = $_[0];
    warn $row->get ('col1'), ",", $row->get ('col2');
    warn $row->get ('count');
  });

=item $result = $db->update ($table_name, $values, where => $where, %opts)

Update rows in the specified table using the SQL C<UPDATE> statement.
The new values must be specified by the second argument, as hash
reference containing name-value pairs representing the column names
and their new values.  A value can be specified as a scalar value (a
text, number, or C<undef> value), or a bare SQL fragment object (a
return value of the C<bare_sql_fragment> method), which would be
inserted to the value portion of the SQL statement.  The conditions to
specify the updated rows, i.e. the C<WHERE> clause, must be specified
as the thrid argument, in the same format as the C<select> method.

In addition, following options can be specified as name-value pairs:

=over 4

=item source_name => string

The name of the data source used to select the database connection.
For more information on how data source is selected, see the
C<execute> method.

=item duplicate => "ignore"

Specifies how "duplicate entry" error is handled by the database.  If
C<ignore> is specified, an C<UPDATE IGNORE> statement is issued such
that any attempt to generate duplicate rows is ignored without errors.
Please note that this statement might ignore other errors as well.  If
this option is not specified, then a normal C<UPDATE> statement is
issued such that any duplication would be reported as an SQL execution
error.

=item order => [column1 => direction, column2 => direction, ...]

The columns and their orders for the sorting, i.e. values for the
C<ORDER BY> clause in the SQL statement.  They must be specified in
the same format as the C<select> method.

This option would have no effect unless there is also the C<limit>
option.

=item limit => number

The maximum number of rows to update, i.e. the value for the C<LIMIT>
clause in the SQL statement.  It must be specified as a non-negative
integer.  If the option is not specified, all the matching rows will
be updated.  Unlike the C<select> method, the C<offset> option is not
supported.

=back

This method returns a result object bound to the table specified as
the first argument.  The number of affected rows can be retrieved from
the C<row_count> method of the result object.  Methods such as C<all>,
C<each>, and C<first> are not available for the result object
generated by this method.

Example:

  $db->update
      ('table1',
       {col1 => 12, col2 => $db->bare_sql_fragment ('col2 + 2')},
       where => {created => {'<=', '2012-01-01 00:00:00'}});
  # UPDATE `table1` SET `col1` = 12, `col2` = col2 + 2
  #    WHERE `created` <= '2012-01-01 00:00:00'

=item $baresql = $db->bare_sql_fragment ($sql_fragment)

Return a bare SQL fragment object for the given SQL statement
fragment.

In general, values specified for the C<update> or C<select> methods
are interpreted as is, possibly stringified.  However, you might
sometimes want to specify a SQL expression such as C<columnname + 1>
or C<NOW()>.

You can specify such a SQL fragment by wrapping it by the bare SQL
fragment object using this method.  Bare SQL fragment objects can be
specified for the values of C<update> method, and the C<duplicate>
values option of the C<insert> method.

CAUTION!  SQL statement fragment is inserted into the SQL statement
constructed by those methods as is without any modifications or
validations.  It means that you have to prevent the fragment from
syntax error, SQL injection vulnerability, or any other possible
errors.

=item $db->delete ($table_name, $where, %opts)

Delete rows in the specified table.  The second argument must specify
the conditions to select the rows to delete, in the same format as the
second argument of the C<select> method.

In addition, following options can be specified as name-value pairs:

=over 4

=item source_name => string

The name of the data source used to select the database connection.
For more information on how data source is selected, see the
C<execute> method.

=item order => [column1 => direction, column2 => direction, ...]

The columns and their orders for the sorting, i.e. values for the
C<ORDER BY> clause in the SQL statement.  They must be specified in
the same format as the C<select> method.

This option would have no effect unless there is also the C<limit>
option.

=item limit => number

The maximum number of rows to delete, i.e. the value for the C<LIMIT>
clause in the SQL statement.  It must be specified as a non-negative
integer.  If the option is not specified, all the matching rows will
be deleted.  Unlike the C<select> method, the C<offset> option is not
supported.

=back

This method returns a result object bound to the table specified as
the first argument.  The number of affected rows can be retrieved from
the C<row_count> method of the result object.  Methods such as C<all>,
C<each>, and C<first> are not available for the result object
generated by this method.

Example:

  $db->delete
      ('table1', {created => {'<=', '2012-01-01 00:00:00'}});
  # DELETE FROM `table1` WHERE `created` <= '2012-01-01 00:00:00'

=item $db->set_tz ($tz_offset, source_name => $source_name)

Set the time zone for the database connection, using C<SET time_zone>
statement.  The time zone offset argument, which is default to UTC,
must be in the format understood by the database, i.e. C<+01:00>.  The
C<source_name> option, defaulted to the C<master>, specifies the data
source for which the time zone is set.

The default time zone used when this statement is not issued depends
on the configuration of the database.

=back

=head2 Schema-aware operations

The following methods provide access to schema-aware APIs.  What is
schema-aware APIs?  Methods mentioned in the previous sections are not
schema-aware.  That is, no SQL data type is different from strings for
the purpose of them.  The schema-aware APIs are built on top of them
to offer an abstract layer for convertion of database and Perl data
types.  For example, if you associated the C<created_on> column with
the C<timestamp_as_DateTime> type handler, where the column is
declared as SQL C<TIMESTAMP> data type in the database schema, you can
use a Perl L<DateTime> object to set the value for the column through
a schema-aware method, and you can retrieve the column value as a
C<DateTime> object from a schema-aware method.

=over 4

=item $db->schema ($schema)

=item $schema = $db->schema

Get or set the schema definition as used by the database object.  The
schema definition has to be set before any schema-aware operation is
actually invoked.

XXX schema definition

=item $table = $db->table ($table_name)

Create a table object for the specified table.  The table object
provides schema-aware APIs for the table.  For more information on the
table object see documentation for the L<Dongry::Table> module.

=item $query = $db->query (%opts)

Create a query object with the specified options.  The query object is
an abstraction for a particular schema-aware C<SELECT> operation.  If
the C<query_class> option is specified, the class is used to
instantiate the query object.  Otherwise, the L<Dongry::Query> class
is used.  For more information, including the list of the other
available options, see documentation for the L<Dongry::Query> module.

=back

=head2 Development

There is a method to help development:

=over 4

=item $string = $db->debug_info

Return a not-so-long string to describe the database object.  It might
or might not be useful for debugging.

=back

=head1 METHODS OF RESULT OBJECT

The result object is an instance of the C<Dongry::Database::Executed>
class.  SQL execution methods of the database object, such as
C<execute> or C<select>, returns an result object.  It has the
following methods:

=over 4

=item $number = $result->row_count

Return the number of rows affected by the SQL execution (for write
operations), or the number of rows found by the SQL execution (for
read operations), as reported by the underlying database driver.

Please note that XXX

=item $name = $result->table_name

Return the name of the table bound to the result object, if any, or
C<undef>.

The result object returned by a table-aware method, such as C<select>
or C<insert>, is bound to a table.  However, a table-unaware method,
such as C<execute>, does not bind any table into the result object.

If the result object is I<not> bound to a table, following C<_as_row>
methods cannot be used.

=item $result->each ($code)

XXX

=item $string = $result->debug_info

Return a short string to describe the result object.  It might or
might not be useful for debugging.

=back

=head1 COMPATIBILITY

Although Dongry is built on the top of the L<DBI>'s standard interface
to various kinds of database backends, its full functionality can be
used only when the database to be connected is MySQL version 5.  Some
of SQL statements generated by Dongry is not supported by other
database management systems.

Some of features provided by Dongry do not work as intended depending
on the database engine in use.  Specifically, transaction does not
work for tables using the MyISAM engine.

=head1 SEE ALSO

L<DBI>.

L<DBD::MySQL>.

MySQL Reference Manuals <http://dev.mysql.com/doc/index.html>.

=head1 ACKNOWLEDGEMENTS

The design of various features of Dongry is inspired by L<DBI>,
L<DBIx::MoCo>, L<DBIx::MoCo::Query>, L<DBIx::MoCo::ColumnMethods>,
L<DBIx::MoCo::TableExtras>, L<SQL::Abstract>,
L<SQL::NamedPlaceholder>, and L<List::Rubyish>.

=head1 AUTHOR

Wakaba <w@suika.fam.cx>.

=head1 LICENSE

Copyright 2011 Wakaba <w@suika.fam.cx>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
